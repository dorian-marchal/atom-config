"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.messages = exports.ruleName = undefined;

exports.default = function (actual) {
  return function (root, result) {
    var validOptions = (0, _utils.validateOptions)(result, ruleName, { actual: actual });
    if (!validOptions) {
      return;
    }

    root.walkRules(function (rule) {
      var ruleSource = rule.source.input.from;
      var ruleParent = rule.parent;
      if (!selectorContextMap.has(ruleSource)) {
        selectorContextMap.set(ruleSource, new Map());
      }
      if (!selectorContextMap.get(ruleSource).has(ruleParent)) {
        selectorContextMap.get(ruleSource).set(ruleParent, new Set());
      }
      var parentSelectorSet = selectorContextMap.get(ruleSource).get(ruleParent);

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = rule.selectors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var selector = _step.value;

          if (parentSelectorSet.has(selector)) {
            return (0, _utils.report)({
              result: result,
              ruleName: ruleName,
              message: messages.rejected(selector),
              node: rule,
              // This means that the first occurence of the violator will be flagged,
              // which is fine (given `a, a {}`, the first `a` selector is flagged)
              index: rule.toString().indexOf(selector)
            });
          }
          parentSelectorSet.add(selector);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    });
  };
};

var _utils = require("../../utils");

var ruleName = exports.ruleName = "no-duplicate-selectors";

var messages = exports.messages = (0, _utils.ruleMessages)(ruleName, {
  rejected: function rejected(selector) {
    return "Unexpected duplicate selector \"" + selector + "\"";
  }
});

// The top level of this map will be rule sources.
// Each source maps to another map, which maps rule parents to a set of selectors.
// This ensures that selectors are only checked against selectors
// from other rules that share the same parent and the same source.
var selectorContextMap = new Map();